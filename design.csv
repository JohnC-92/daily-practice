Familiarity,System Question,Key Points,Description
0,Design URL shortener,"Core APIs: POST /shorten {long_url, custom_alias?, expire_at?} returns {short_url}; GET /{code} does a 301/302 redirect to the long URL. Keep APIs boring and predictable.
–SEPARATOR–
Code generation: Use a unique ID (auto-increment, Snowflake, or UUID) and encode to Base62 for short codes. Intuition: don’t “invent” uniqueness with random strings unless you’re ready to handle collisions.
–SEPARATOR–
Storage model: Primary table {code -> long_url, created_at, expire_at, owner_id, status}; secondary index on owner_id for “my links”. Keep reads O(1) by key.
–SEPARATOR–
Read path is king: Redirects are vastly more frequent than creates, so optimize GET /{code} with cache (Redis/Memcached) in front of the DB. Intuition: every extra millisecond on redirect gets multiplied by the entire internet.
–SEPARATOR–
Caching strategy: Cache code -> long_url with TTL; negative-cache missing/disabled codes briefly to reduce DB hammering. Pre-warm hot links if needed.
–SEPARATOR–
Database choice & scale: Start with a relational DB or key-value store; shard/partition by code or id as traffic grows. Intuition: sharding by code keeps lookups simple and evenly spread.
–SEPARATOR–
Custom aliases: If custom_alias provided, treat as reserved key; enforce uniqueness with a transactional write or conditional put. Rate-limit to prevent squatting.
–SEPARATOR–
Expiration & deletion: Store expire_at; on read, treat expired as not found (or gone). Clean-up via background jobs (batch delete) but keep read-path checks lightweight.
–SEPARATOR–
Redirect semantics: Use 302 by default (lets you change destination later), 301 for “permanent” links. Add safety checks to avoid open redirect abuse if you support advanced routing.
–SEPARATOR–
Abuse prevention: Rate limit shorten, blacklist/allowlist domains, malware scanning hooks, captcha for anonymous users, and monitoring for suspicious spikes. Intuition: shorteners are magnets for spam.
–SEPARATOR–
Analytics (optional): Don’t block redirects to write analytics. Emit async events (queue/stream) for click logs, aggregate later (counts by day, referrer, geo). Intuition: redirects should be “read-only fast”.
–SEPARATOR–
High availability: Multi-replica DB, cache replication, stateless app servers behind a load balancer. Plan for cache miss storms and DB failover.
–SEPARATOR–
Consistency & idempotency: Make shorten idempotent if clients retry (client token or hash of long_url+owner). Intuition: retries happen; duplicates shouldn’t multiply like gremlins.
–SEPARATOR–
Security: Validate URLs, protect admin operations, guard against SSRF-style internal URLs (if your infra is sensitive), and ensure HTTPS for short links.","Design a service that takes a long URL and returns a short URL, then redirects users from the short URL back to the original long URL. It should handle high read traffic (redirects), support creating new short links, and remain reliable, fast, and safe at scale."
0,Design Rate Limiter,"1. What are we limiting?

Decide the identity key: IP address, user ID, API key, or token.
Intuition: rate limiting is meaningless unless you define who is being limited.

–SEPARATOR–

2. Where to enforce the limit?

Client-side, API gateway, load balancer, or service-level.
Intuition: enforce as early as possible to avoid wasting downstream resources.

–SEPARATOR–

3. Rate limiting algorithms
	•	Fixed window: simple but bursty at window edges
	•	Sliding window: smoother but more expensive
	•	Token bucket: allows bursts, common in practice
	•	Leaky bucket: steady outflow, strict smoothing
Intuition: algorithm choice is a tradeoff between accuracy, burst tolerance, and cost.

–SEPARATOR–

4. Time window definition

Seconds, minutes, or rolling intervals.
Intuition: shorter windows = more precise control but higher overhead.

–SEPARATOR–

5. Distributed rate limiting

Use centralized storage like Redis or Memcached.
Intuition: multiple servers must share state or limits will be bypassed.

–SEPARATOR–

6. Atomicity and concurrency

Use atomic operations (INCR + EXPIRE, Lua scripts).
Intuition: race conditions can silently break your limits.

–SEPARATOR–

7. Storage strategy

In-memory cache vs persistent store.
Intuition: rate-limit data is short-lived, so fast volatile storage is ideal.

–SEPARATOR–

8. Failure behavior

Fail-open (allow traffic) vs fail-closed (block traffic).
Intuition: availability vs protection, depends on business risk.

–SEPARATOR–

9. Configurability

Different limits per API, user tier, or region.
Intuition: real systems need flexible policies, not one global rule.

–SEPARATOR–

10. Response behavior

Return HTTP 429 with retry headers (Retry-After).
Intuition: clients should know when they can retry.

–SEPARATOR–

11. Performance impact

Rate limiting must be extremely fast (sub-millisecond).
Intuition: the guardrail must not become the bottleneck.

–SEPARATOR–

12. Monitoring and observability

Track blocked requests, hot keys, and limit breaches.
Intuition: limits without visibility become invisible failures.","Design a rate limiter that controls how many requests a client can make to a system within a given time window.

The system should:
	•	Protect backend services from overload
	•	Prevent abuse (spam, DDoS, brute force)
	•	Support different limits (per user, IP, API key, endpoint)
	•	Work correctly in a distributed system
	•	Be performant and highly available"