,,,,,,,
ID,Name,Times Submitted,Reason for fail,Takeaway,Follow Up,Time Complexity,Space Complexity
0,1039. Minimum Score Triangulation of Polygon,Cant do at all,cant derive dp relation and bottom up,"Matrix chain multiplication / Interval DP, same template for bottom up / top down",,n^3,n^2
1,2221. Find Triangular Sum of an Array,1,,"Pascal triangle property each number contribution is comb(n - 1, i) * nums[i]",,n^2 / n (Pascal),n
2,1518. Water Bottles,1,,simulate of use equation / math solution - number_bottles + (number_bottles - 1) // (num_exchange - 1),,log(bottle) / 1,1
2,3100. Water Bottles II,1,,simulate drink water equation / math solution - ,,log(bottle) / 1,1
0,407. Trapping Rain Water II,Cant do at all,"not two pointer, but djisktra / bfs + heap",get lowest wall from all directions --> MIN HEAP from all wall edges,,r * c * (log (r * c)),r * c
2,11. Container With Most Water,1,,Only higher line contribute to area (greedy idea),,n,1
2,417. Pacific Atlantic Water Flow,1,,"No minimum property like in leetcode 407, so dfs/bfs ok, walk from edge because else it will be walk from every cell, which is worst case mn * mn

If you propagate backwards, you turn the problem into a clean multi source flood-fill.

This trick is common: when the condition is defined by touching the boundary, you usually flip the perspective and search from the boundary inwards.",,m * n ,m * n 
2,1135. Connecting Cities With Minimum Cost,1,,"keyword: minimum cost to connect cities --> kruskal (sort + union find)  / prim (use min heap, take min for each edge), union find union function is ackerman constant for time complexity",,e (edges) log e,e + v
1,778. Swim in Rising Water,,can do with djisktra / BFS with priority queue,,,m * n log (m * n),1
0,1488. Avoid Flood in The City,,,,,,
0,2300. Successful Pairs of Spells and Potions,,,,,,
0,774. Minimize Max Distance to Gas Station,,,,,,
0,3494. Find the Minimum Amount of Time to Brew Potions,,,,,,
0,3147. Taking Maximum Energy From the Mystic Dungeon,,,,,,
0,3186. Maximum Total Damage With Spell Casting,,,,,,
0,3539. Find Sum of Array Product of Magical Sequences,X,,,,,
0,2273. Find Resultant Array After Removing Anagrams,,,,,,
0,3346. Maximum Frequency of an Element After Performing Operations I,X,freq count + prefix sum to get count of numbers in range,PREFIX SUM,,n max (max num in nums),n max
0,3347. Maximum Frequency of an Element After Performing Operations II,X,sort + binary search to get all numbers in a range,"MUST SORT, intuition is best group must lie together, sliding window with distance constraint as shrinking condition (COND --> after sorting, nums[i] and nums[j] can come together if nums[j] - nums[i] < 2* k)

BINARY SEARCH (IDEA FROM LARRY):
for every number it can be [x, x + k, x - k], and for each number, we try to take all take are in range of [num - k, num + k] by using bisect_left(nums, num-k), bisect_right(nums, num+k), and taking right - left indexes and take min(operations, right - left)",,n log n,number of distinct nums
0,1838. Frequency of the Most Frequent Element,X,cant see sliding window,"MUST SORT, intuition is best group must lie together, sliding window with cost constraint as shrinking condition (VALID COND --> largest_num_in_window * window < window_sum - k)",,n log n,1
0,2048. Next Greater Numerically Balanced Number,,"cant translate intuition to answer, core lies in generate all multi set for length N, e.g.
{1, 4}, and only need to pick smallest and compare, if no valid then go to length N + 1

LARRY, brute force can work, just try all 1 million numbers and take the ones that satisfy condition",,,,
2,1716. Calculate Money in Leetcode Bank,,simulate,,,log7 n? (keep divide 7),1
2,2125. Number of Laser Beams in a Bank,,simulate,,,n,1
0,1570. Dot Product of Two Sparse Vectors,X,">>>> SPARSE VECTOR
using array directly waste a lot of space
think hashmap / two pointer for values, and skip zeroes
follow up: if one is sparse, use index in sparse + binary search the non sparse array","hashmap -> skip zero, save values, loop through values, if the other has value then multiply

array pairs (idx, val) + two pointer -> if index same, then multiply, else skip","one vector sparse, the other vector not sparse",n + m,length of n with value + length of m with value
0,311. Sparse Matrix Multiplication,,,"use array pairs idea from 1570, the final matrix will be row vectors from matrix1, col vectors from matrix2",expand 1570 idea to 2d,,
1,3354. Make Array Elements Equal to Zero,,"missed the case when abs(r_sum - l_sum) == 1, didnt think brute force intution clear enough","either use prefix sum and get l_sum + r_sum, or we can calculate total_sum, and when running through, left += curr_num, right = total_sum - curr_num",,n,n
2,3370. Smallest Number With All Set Bits,,"add one more digit to current binary length, then minus 1",,,1 / n,1
1,1526. Minimum Number of Increments on Subarrays to Form a Target Array,,,,,n,1
0,656. Coin Path,,"totally forgot basics dp, on how dp transition with different states

this is 1d dp added with additional stuff brought on","if there are dp again, rethink what are the core of dp:

when do we use DP?

base cases
how to define states
state transition function",,,
0,2464. Minimum Subarrays in a Valid Split,,"doesnt know how to check subarray, substring dp

which is actually the same as Longest Increasing Subsequence

for i in range(n):
    for j in range(i):

or

for i in range(n):
    for j in range(i, n):

also similar to Work Break, Work Break II (follow up with paths building)","we can reuse the result from previous

think if array[0:3] work, we save it,
in future if array[4:6] work, we take 4 - 1 which is 3,
and then add to current result, so we know at 6 it will be 2

this is the exact core intution for subarray / substring with dp

and for interval dp / palindrome like,
its similar,

we will have already compute some dp[left+1: right - 1] previously
and we can expand from there",,,
2,3217. Delete Nodes From Linked List Present in Array,,,"use two pointer, one to track prev, and one to track current, skip with prev.next = curr.next when we see curr.value is invalid num",,n,1
0,1183. Maximum Number of Ones,,,,,,
1,2257. Count Unguarded Cells in the Grid,3,"didn think of edge case where guards overlap, or when we use the seen set, but then when the other guard walking here, we stop due to the seen set, its not how this works","use BFS multi source guard, but no use QUEUE, just simulate repeated walk with while loop, and only stop with invalid index, walls and guards, basically try simulating walk till dead end:

        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for gr, gc in guard:
            for dr, dc in dirs:
                r, c = gr + dr, gc + dc
                while 0 <= r < m and 0 <= c < n and (r, c) not in blocked:
                    seen.add((r, c))
                    r += dr
                    c += dc",,m * n,m * n
2,1578. Minimum Time to Make Rope Colorful,1,,"basically simulation, do what the question ask, which is go through string, if repeat then only leave the largest time, and remove all the other times",,n,1
2,3318. Find X-Sum of All K-Long Subarrays I,,,"do what the question ask you to do, which is sliding window and take window higher frequency two element by sorting",,,
0,3321. Find X-Sum of All K-Long Subarrays II,,,previous will not work,,,
1,3607. Power Grid Maintenance,2,"after joining the nodes, dont know how to give a special unique id for nodes

later i use the root for the component after all the union find join","think thoroughly before brute forcing through your idea, like slow down and think carefully",,n log n,n
0,2528. Maximize the Minimum Powered City,X,binary search min/max + sliding window + deque,,,n log n,1
0,1611. Minimum One Bit Operations to Make Integers Zero,X,,,,,
2,2169. Count Operations to Obtain Zero,,"basically GCD equation:
take large num divide by small num, then we need to do that many times of operation, then we are left with num1 % num2, then swap to take larger 1 as num1 and repeat

        while num1 != 0 and num2 != 0:
            ops += num1 // num2
            num1 = num1 % num2
            num1, num2 = num2, num1","we do simulation because cant greedy after testing cases

also remember this as GCD equation",,,
0,3542. Minimum Operations to Convert All Elements to Zero,X,"2 ideas:
monotonic stack (by LARRY, instinct of seeing numbers go up and down, and probably look back -> STACK):
if we have larger, means we need operations, if we have smaller, than pop the previous, if we have the same, do nothing because its what we wanted

linked list (by LARRY)
i am thinking we need to find the same numbers index, but we dont know how to do this effiicent
larry thought of linked list",,,n,1
1,474. Ones and Zeroes,2,"you forgot knapsack dp basic template (take / no take)

        @cache
        def dfs(i, m_count, n_count):
            if i == len(strs):
                return 0
            
            # take
            take = 0
            if m_count + count[(i, ""0"")] <= m and n_count + count[(i, ""1"")] <= n:
                take = 1 + dfs(i + 1, m_count + count[(i, ""0"")], n_count + count[(i, ""1"")])

            # no take
            no_take = dfs(i + 1, m_count, n_count)
            return max(take, no_take)

        return dfs(0, 0, 0)",,,length * m_count * n_count,n
2,170. Two Sum III - Data structure design,,"design problem:
2 different kind of data structure: dict + array

","no greedy way to improve so we must loop n length

thats why i think of array to save number and loop every one, and then num_freq dict to check if have the number like in two sum, but we only need to do once which is during add",,n,n
0,2654. Minimum Number of Operations to Make All Array Elements Equal to 1,X,"you dont understand gcd property.

3 case:
1. have 1, then operations = n - number_of_ones
2. gcd of all numbers > 1, none gcd can go down to zero
3. get smallest subarray with gcd = 1 with brute force double for loop g = gcd(g, nums[j])","gcd will not increase if we keep doing gcd, because at most it will be the num itself or lower

therefore we can continuosly do gcd on array of numbers to get some property",,n^2 log n,1
0,3228. Maximum Number of Operations to Move Ones to the End,X,dont get the greedy idea of counting the moves with number of ones accumulated so far,,,n,1
0,2536. Increment Submatrices by One,X,"diff array trick, you add 1 at start of index, and minus 1 at end of index, the effect of 1 will bring on so you dont have to add for each index","1d diff array vs 2d diff array

## ========== 1d ==========
# diff array of size n+1 (to allow r+1 safely)
diff[l] += val
diff[r + 1] -= val

arr = [0] * n
curr = 0
for i in range(n):
    curr += diff[i]
    arr[i] = curr

## ========== 2d ==========
diff[r1][c1]         += val
diff[r1][c2 + 1]     -= val
diff[r2 + 1][c1]     -= val
diff[r2 + 1][c2 + 1] += val

for r in range(n):
    for c in range(m):
        if r > 0:
            diff[r][c] += diff[r - 1][c]
        if c > 0:
            diff[r][c] += diff[r][c - 1]
        if r > 0 and c > 0:
            diff[r][c] -= diff[r - 1][c - 1]",,n^2,n^2
0,3234. Count the Number of Substrings With Dominant Ones,XX,,,,,
1,1513. Number of Substrings With Only 1s,,,"consecutive ones can contribute these many substring:

for example:
""111"" can contribute 6 substrings of 1

two ways to calculate:
either 1 + 2 + 3 = 6 or
3 * (3 + 1) / 2 = 6 --> n * (n + 1) / 2",,n,1
2,1437. Check If All 1's Are at Least Length K Places Away,,,"when meet 1, then reset counter, or another idea
when meet 1, check the window length r - l + 1 > k",,n,1
2,717. 1-bit and 2-bit Characters,,,"if num is 0, i += 1, if num is 1, i += 2",,n,1
2,2154. Keep Multiplying Found Values by Two,,,"need find if exists in num, so idea is use a set",,n,n
1,1930. Unique Length-3 Palindromic Subsequences,,"when see subsequence, what comes to your mind??? 

DP / brute force all with cache

this question is special though, because the length 3, we can fix start and end and grab center str

palindromes = len(set(s[char_start_idx + 1: char_end_idx ]))",,n,n,
2,3190. Find Minimum Operations to Make All Elements Divisible by Three,,"all the distance for numbers other than 3,6,9 must have distance of 1, for example , 4 can minus 1 to get 3, or 5 can add 1 to get 6",,n,1,
0,1262. Greatest Sum Divisible by Three,X,"dont get the idea of remainder, remainder with mod is like a circle, if mod 3, the remainder have only 3 cases:
- remain 0
- remain 1
- remain 2",,n,1,
0,757. Set Intersection Size At Least Two,X,"interval sorting introduce some kind of constraint on the intervals

therefore if we want the numbers to intersect as much as possible we sort by end, and then take the left most two numbers",,n log n,1,
1,259. 3Sum Smaller,,"similar to 3sum, but differ at the part where the numbers are valid:

when we use two pointer and see a valid num, the following will are be valid nums, therefore valid choices:
window of r - l",,n^2,1,
1,1015. Smallest Integer Divisible by K,X,"find digits of 1,11,111,1111,11111... that can be divided by k

idea is a BFS idea for available digit, in this case 1, the equation is:
rem = (rem * 10 + 1) % k

remainders has k buckets, and so that can be only at most K times to run

important idea: if remainder repeat, then it will repeat infinitely",,k,1,
0,2435. Paths in Matrix Whose Sum Is Divisible by K,X,"similar idea to MOD family, remainder state will only have k so we can compress all sum into k remainders

TOP DOWN
def dfs(r, c, rem) <--- r * c * k

BOTTOM UP",,,,
0,3381. Maximum Subarray Sum With Length Divisible by K,X,"group all the different prefix sums at indexes into the same group with:
rem = index % k

for each rem, we always take the minimum of curr_sum and record it:
min_rem[rem] = min(min_rem[rem], sum_at_idx)

idea is because we need subarray of length nk, so we have to subtract something:

class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        min_pref = [float(""inf"")] * k
        min_pref[-1 % k] = 0

        sums = 0
        best = float(""-inf"")
        for i in range(n):
            sums += nums[i]
            rem = i % k
            if min_pref[rem] != float(""inf""):
                best = max(best, sums - min_pref[rem])
            min_pref[rem] = min(min_pref[rem], sums)
        return best
",,,,
0,2872. Maximum Number of K-Divisible Components,,"greedy idea:
if subtree sum mod is zero, return +1 component and sum = 0",,n,1,
2,3512. Minimum Operations to Make Array Sum Divisible by K,,the remainder is the operations needed to do nums[i] -> nums[i] - 1,,1,1,
2,370. Range Addition,,"to do range addition, we do diff array, this is basically 1d diff array

for the range addition,
at num[startidx] += num,
at num[endIdx + 1] -= num",,n,1,
0,1590. Make Sum Divisible by P,,"this is combo question:
- subarray divisible P
- remove another subarray to make it divisible

basic equation:
pref[r + 1] % k ==  pref[l] % k
(pref[r + 1] - pref[l]) % k == 0

advanced intermediate equation:
(pref[r+1] - pref[l]) % p == target_remainder

rearrange:
pref[l] % p == (pref[r + 1] - target_remainder) % p

therefore:
need = (pref[r + 1] - target_remainder + p) % p

","class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        total = sum(nums)
        target = total % p
        if target == 0:
            return 0

        pref = {0: -1}  # prefix_mod_p -> latest index
        current_sum = 0
        best = float(""inf"")

        for i, num in enumerate(nums):
            current_sum += num
            current_mod = current_sum % p

            # We want: (current_mod - prev_mod) % p == target
            # ‚Üí prev_mod ‚â° (current_mod - target) % p
            needed = (current_mod - target) % p

            if needed in pref:
                best = min(best, i - pref[needed])

            pref[current_mod] = i

        return best if best != float(""inf"") and best < len(nums) else -1",n,1,
0,2141. Maximum Running Time of N Computers,,"when binary search valid range:

upper range -> mid = r:
use mid = l + (r-l) // 2

lower range -> mid = l:
use mid = (l + r + 1) // 2

idea is use binary search on target minutes:
","class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        l, r = 1, sum(batteries) + 1
        while l < r:
            mid = (l + r + 1) // 2
            minutes = 0
            for battery in batteries:
                minutes += min(battery, mid)
            
            if minutes >= n * mid:
                l = mid
            else:
                r = mid - 1
            
        return l",log n,1,
0,1214. Two Sum BSTs,,"For ‚Äúfind a pair across two arrays (or in one array) that satisfies something like a + b == target / a == b / a in other array‚Äù, the 3 classic tools really are:

üîπ Hash set
üîπ Binary search
üîπ Two pointers

","üîπ Hash set
# A, B are arrays (unordered)
s = set(A)
for x in B:
    if target - x in s:
        return True
return False

üîπ Binary search
B is sorted
import bisect

B.sort()  # if not already sorted

for x in A:
    want = target - x
    i = bisect.bisect_left(B, want)
    if i < len(B) and B[i] == want:
        return True
return False

üîπ Two pointers
Two-array version
l, r = 0, len(arr) - 1
while l < r:
    s = arr[l] + arr[r]
    if s == target: ...
    elif s < target: l += 1
    else: r -= 1
Two-array version
i = 0             # start of A (smallest)
j = len(B) - 1    # end of B (largest)

while i < len(A) and j >= 0:
    s = A[i] + B[j]
    if s == target:
        return True
    elif s < target:
        i += 1    # need larger sum ‚Üí move A up
    else:
        j -= 1    # need smaller sum ‚Üí move B down
",,,
0,3623. Count Number of Trapezoids I,,,"put same row points into dict, pick any 2 them out using:
math.comb(points, 2) or n * (n - 1) // 2

also, the trick to count the edges fast is to add them each time and times the new edges",n,1,
0,3625. Count Number of Trapezoids II,,,"- use slope + constants to define line to group points
- use dy (y2 - y1), dx (x2 - x1) of points + g = lcm(dx, dy) so its dy// g and dx // g to avoid precision problem of slope and group points
- same picking techinique of math.comb(points on slope, 2)
- need minus repeated count of paralleogram (track with mid points), and add back degenerate

- parallelogram double counted -> use mid point trick:
(x1 + x2) // 2 =  (x3 + x4) // 2 = (x5 + x6) // 2

- degenerate parallelograms (4 points on a straightline), use same mid point trick idea on same slope points which has more than 4 points",n^2,n^2,
1,2211. Count Collisions on a Road,,"only account collision of previous index, but if previous index collides, all the previous cars coming will also chain collide","idea:
- strip all starting ""L"" they just go away
- strip all ending ""R"" they just go away
- count all non ""s"" stationary in between for collision count",n,1,
2,3432. Count Partitions with Even Sum Difference,,,"uses the common idea of having full_sum = sum(nums), then start from first index:
you get:

left partition sum = cumulate sum
right partition sum = full_sum - cumulate sum
",n,1,
0,3578. Count Partitions With Max-Min Difference at Most K,X,,,,,
1,1523. Count Odd Numbers in an Interval Range,,,"think all the cases, especially the different starts with odd number and even numbers",1,1,
1,1925. Count Square Sum Triples,,"not special math formula needed, do as the question says:
math.sqrt (a * a + b * b) = c","        pairs = 0
        for n1 in range(1, n):
            for n2 in range(1, n + 1):
                num_sum = n1 * n1 + n2 * n2
                num_sqrt = math.sqrt(num_sum)
                if num_sqrt <= n and int(num_sqrt) ** 2 == num_sum:
                    pairs += 1
        
        return pairs",n^2,1,
0,3583. Count Special Triplets,X,"how to count special triplets where:
- 0 <= i < j < k < n, where n = nums.length
- nums[i] == nums[j] * 2
- nums[k] == nums[j] * 2

no greedy is allowed, because of index constraint","idea:
use freq_prev and freq_next, you can get this using exact same precount full sum idea, we can precount frequency, and minus them on the fly to get prev freq and next freq

class Solution:
    def specialTriplets(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        freq_next = Counter(nums)
        freq_prev = defaultdict(int)
        ans = 0
        for num in nums:
            freq_next[num] -= 1
            target = 2 * num
            ans += (freq_prev[target] * freq_next[target]) % MOD
            freq_prev[num] += 1
        return ans % MOD",n,n,
0,3577. Count the Number of Computer Unlocking Permutations,X,"you are trying to do the permutation, but you dont actually need to because we dont need the real order, we just need the count!

only when we need the order we need REAL BACKTRACK, PERMUTATION, else the time complexity can be reduced 100%

core: permutation count formula:
        ans = 1
        for i in range(2, n):
            ans = ans * i % MOD # fast","idea:

first number must be first num index, and all the other can be picked randomly, minus the invalid choices

class Solution:
    def countPermutations(self, complexity: List[int]) -> int:
        MOD = 10 ** 9 + 7
        n = len(complexity)
        zero_num = complexity[0]
        for i in range(1, n):
            if complexity[i] <= zero_num:
                return 0

        ans = 1
        for i in range(2, n):
            ans = ans * i % MOD # fast
        return ans % MOD
",n,1,
1,3531. Count Covered Buildings,,"you dont know how to cover the points, ",,,,
1,3433. Count Mentions Per User,,"trick:
if original data has problem sorting with STRING, just replace them with numbers","- init all user mentions
- init online users
- sort events according to timestamp and message type

- do as the question say, when offline put in deque and remove from online users, when mention add all the online users",m log m,1,
2,3606. Coupon Code Validator,,"do as the question says, find all valid coupons and sort accordingly",,n log n,1,
2,1874. Minimize Product Sum of Two Arrays,,,"trick:
to minimize product from two array, think take smallest from one, and largest from the other",,,
0,2147. Number of Ways to Divide a Long Corridor,,,,,,
1,2110. Number of Smooth Descent Periods of a Stock,,,,,,
0,3562. Maximum Profit from Trading Stocks with Discounts,,,,,,
0,3573. Best Time to Buy and Sell Stock V,,,,,,
0,3652. Best Time to Buy and Sell Stock using Strategy,,,,,,
0,2092. Find All People With Secret,,,,,,
0,944. Delete Columns to Make Sorted,,,,,,
0,955. Delete Columns to Make Sorted II,,,,,,
0,960. Delete Columns to Make Sorted III,,,,,,
0,2054. Two Best Non-Overlapping Events,,,,,,
0,3074. Apple Redistribution into Boxes,,,,,,
0,3075. Maximize Happiness of Selected Children,,,,,,
0,2483. Minimum Penalty for a Shop,,,,,,
0,2402. Meeting Rooms III,,,,,,
2,1351. Count Negative Numbers in a Sorted Matrix,,,,,,
0,756. Pyramid Transition Matrix,,,,,,
0,840. Magic Squares In Grid,,,,,,
0,1970. Last Day Where You Can Still Cross,,,,,,
2,66. Plus One,,,,,,
2,961. N-Repeated Element in Size 2N Array,,,,,,
0,1411. Number of Ways to Paint N √ó 3 Grid,,,,,,
0,1931. Painting a Grid With Three Different Colors,,,,,,
0,1975. Maximum Matrix Sum,,,,,,